
* Generate a function called 'make_NAME_OF_PARSER()'. This creates the data
  structures needed by the parser and gives them to 'parser_new()'.

* Have an enum for each of the ast_tree_t's type values. Have a way to get the
  string that corresponds to that enum by having a function that indexes into
  an array of the string values or returns NULL for an invalid enum value. This
  provides a similar API for handling ASTs as java's Type and scheme and ruby's
  symbols.

* Change cache to store void* pointers instead of cache_value_t*'s.

* Maintain a vector of the cache contents so that we know what we need to
  free after parsing.

* Seperate the cache into a base hash_map and a cache that extends it with
  funtion pointers for handling the custom keys.

* After parsing, use another hash_map to help to free AST only once and only if
  they aren't in our final result AST.

* Need to free each cache value and the ASTs that aren't used in the final
  tree.

  After parsing, we need to do a traversal of the AST (if it's not NULL) and
  put each pointer into a hash map. Then, as we free the cache in the inner
  parser, we make sure that we don't free our final result AST but, do (only
  once) free the other cached AST values. When doing that, we need to
  recursively delete the AST results but keep track of those things we have
  already freed. We can't just do a non-recursive delete on each result not in
  our final tree because we aren't memoizing every expression so single
  character ASTs wouldn't be in the cache by them selves.

  Or, another way to do it would be to seperately keep track of the non-NULL
  AST results that have been put into the cache.
